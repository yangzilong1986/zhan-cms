/*
 * This source file was generated by FireStorm/DAO.
 * 
 * If you purchase a full license for FireStorm/DAO you can customize this header file.
 * 
 * For more information please visit http://www.codefutures.com/products/firestorm
 */

package zt.cms.xf.common.jdbc;

import zt.cms.xf.common.dao.*;
import zt.cms.xf.common.factory.*;
import java.util.Date;
import java.math.BigDecimal;
import zt.cms.xf.common.dto.*;
import zt.cms.xf.common.exceptions.*;
import java.sql.Connection;
import java.util.Collection;
import org.apache.log4j.Logger;
import java.sql.PreparedStatement;
import java.sql.Statement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Time;
import java.util.List;
import java.util.Iterator;
import java.util.ArrayList;

public class XfcontractDaoImpl extends AbstractDAO implements XfcontractDao
{
	/** 
	 * The factory class for this DAO has two versions of the create() method - one that
takes no arguments and one that takes a Connection argument. If the Connection version
is chosen then the connection will be stored in this attribute and will be used by all
calls to this DAO, otherwise a new Connection will be allocated for each operation.
	 */
	protected java.sql.Connection userConn;

	protected static final Logger logger = Logger.getLogger( XfcontractDaoImpl.class );

	/** 
	 * All finder methods in this class use this SELECT constant to build their queries
	 */
	protected final String SQL_SELECT = "SELECT APPNO, CONTRACTNO, APPTYPE, INTERESTTYPE, STARTDATE, PLACE, CONTRACTTYPE, CSTATUS, DURATION, CURNO, CONTRACTAMT, PRINCIPALAMT, SERVICECHARGE, LATEFEERATE, BREACHFEERATE, MANAGERFEERATE, LOWESTLATEFEE, PARTNERNAME, PARTNERACT, PARTNERBANKID, PARTNERBANKNO, PARTNERBANKNAME, COMMNAME, COMMTYPE, COMMNUM, CLIENTNO, CLIENTIDTYPE, CLIENTID, CLIENTNAME, PAYBACKACT, PAYBACKACTNAME, PAYBACKBANKID, PAYBACKBANKNO, PAYBACKBANKNAME, CLIENTACT, OPERATORID, OPERATEDATE, CHECKERID, CHECKDATE, REMARK, CREATORID, CREATEDATE, CREATEFORM, UPDATORID, UPDATEDATE, UPDATEFORM, CUSTOMER_CODE, SIGN_ACCOUNT_NO, RECEIVEAMT, WITHHOLDBANKNAME, COMMAMT, TERMINALCD, TERMINALDATE, TERMINALREASON FROM " + getTableName() + "";

	/** 
	 * Finder methods will pass this value to the JDBC setMaxRows method
	 */
	protected int maxRows;

	/** 
	 * SQL INSERT statement for this table
	 */
	protected final String SQL_INSERT = "INSERT INTO " + getTableName() + " ( APPNO, CONTRACTNO, APPTYPE, INTERESTTYPE, STARTDATE, PLACE, CONTRACTTYPE, CSTATUS, DURATION, CURNO, CONTRACTAMT, PRINCIPALAMT, SERVICECHARGE, LATEFEERATE, BREACHFEERATE, MANAGERFEERATE, LOWESTLATEFEE, PARTNERNAME, PARTNERACT, PARTNERBANKID, PARTNERBANKNO, PARTNERBANKNAME, COMMNAME, COMMTYPE, COMMNUM, CLIENTNO, CLIENTIDTYPE, CLIENTID, CLIENTNAME, PAYBACKACT, PAYBACKACTNAME, PAYBACKBANKID, PAYBACKBANKNO, PAYBACKBANKNAME, CLIENTACT, OPERATORID, OPERATEDATE, CHECKERID, CHECKDATE, REMARK, CREATORID, CREATEDATE, CREATEFORM, UPDATORID, UPDATEDATE, UPDATEFORM, CUSTOMER_CODE, SIGN_ACCOUNT_NO, RECEIVEAMT, WITHHOLDBANKNAME, COMMAMT, TERMINALCD, TERMINALDATE, TERMINALREASON ) VALUES ( ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ? )";

	/** 
	 * SQL UPDATE statement for this table
	 */
	protected final String SQL_UPDATE = "UPDATE " + getTableName() + " SET APPNO = ?, CONTRACTNO = ?, APPTYPE = ?, INTERESTTYPE = ?, STARTDATE = ?, PLACE = ?, CONTRACTTYPE = ?, CSTATUS = ?, DURATION = ?, CURNO = ?, CONTRACTAMT = ?, PRINCIPALAMT = ?, SERVICECHARGE = ?, LATEFEERATE = ?, BREACHFEERATE = ?, MANAGERFEERATE = ?, LOWESTLATEFEE = ?, PARTNERNAME = ?, PARTNERACT = ?, PARTNERBANKID = ?, PARTNERBANKNO = ?, PARTNERBANKNAME = ?, COMMNAME = ?, COMMTYPE = ?, COMMNUM = ?, CLIENTNO = ?, CLIENTIDTYPE = ?, CLIENTID = ?, CLIENTNAME = ?, PAYBACKACT = ?, PAYBACKACTNAME = ?, PAYBACKBANKID = ?, PAYBACKBANKNO = ?, PAYBACKBANKNAME = ?, CLIENTACT = ?, OPERATORID = ?, OPERATEDATE = ?, CHECKERID = ?, CHECKDATE = ?, REMARK = ?, CREATORID = ?, CREATEDATE = ?, CREATEFORM = ?, UPDATORID = ?, UPDATEDATE = ?, UPDATEFORM = ?, CUSTOMER_CODE = ?, SIGN_ACCOUNT_NO = ?, RECEIVEAMT = ?, WITHHOLDBANKNAME = ?, COMMAMT = ?, TERMINALCD = ?, TERMINALDATE = ?, TERMINALREASON = ? WHERE CONTRACTNO = ?";

	/** 
	 * SQL DELETE statement for this table
	 */
	protected final String SQL_DELETE = "DELETE FROM " + getTableName() + " WHERE CONTRACTNO = ?";

	/** 
	 * Index of column APPNO
	 */
	protected static final int COLUMN_APPNO = 1;

	/** 
	 * Index of column CONTRACTNO
	 */
	protected static final int COLUMN_CONTRACTNO = 2;

	/** 
	 * Index of column APPTYPE
	 */
	protected static final int COLUMN_APPTYPE = 3;

	/** 
	 * Index of column INTERESTTYPE
	 */
	protected static final int COLUMN_INTERESTTYPE = 4;

	/** 
	 * Index of column STARTDATE
	 */
	protected static final int COLUMN_STARTDATE = 5;

	/** 
	 * Index of column PLACE
	 */
	protected static final int COLUMN_PLACE = 6;

	/** 
	 * Index of column CONTRACTTYPE
	 */
	protected static final int COLUMN_CONTRACTTYPE = 7;

	/** 
	 * Index of column CSTATUS
	 */
	protected static final int COLUMN_CSTATUS = 8;

	/** 
	 * Index of column DURATION
	 */
	protected static final int COLUMN_DURATION = 9;

	/** 
	 * Index of column CURNO
	 */
	protected static final int COLUMN_CURNO = 10;

	/** 
	 * Index of column CONTRACTAMT
	 */
	protected static final int COLUMN_CONTRACTAMT = 11;

	/** 
	 * Index of column PRINCIPALAMT
	 */
	protected static final int COLUMN_PRINCIPALAMT = 12;

	/** 
	 * Index of column SERVICECHARGE
	 */
	protected static final int COLUMN_SERVICECHARGE = 13;

	/** 
	 * Index of column LATEFEERATE
	 */
	protected static final int COLUMN_LATEFEERATE = 14;

	/** 
	 * Index of column BREACHFEERATE
	 */
	protected static final int COLUMN_BREACHFEERATE = 15;

	/** 
	 * Index of column MANAGERFEERATE
	 */
	protected static final int COLUMN_MANAGERFEERATE = 16;

	/** 
	 * Index of column LOWESTLATEFEE
	 */
	protected static final int COLUMN_LOWESTLATEFEE = 17;

	/** 
	 * Index of column PARTNERNAME
	 */
	protected static final int COLUMN_PARTNERNAME = 18;

	/** 
	 * Index of column PARTNERACT
	 */
	protected static final int COLUMN_PARTNERACT = 19;

	/** 
	 * Index of column PARTNERBANKID
	 */
	protected static final int COLUMN_PARTNERBANKID = 20;

	/** 
	 * Index of column PARTNERBANKNO
	 */
	protected static final int COLUMN_PARTNERBANKNO = 21;

	/** 
	 * Index of column PARTNERBANKNAME
	 */
	protected static final int COLUMN_PARTNERBANKNAME = 22;

	/** 
	 * Index of column COMMNAME
	 */
	protected static final int COLUMN_COMMNAME = 23;

	/** 
	 * Index of column COMMTYPE
	 */
	protected static final int COLUMN_COMMTYPE = 24;

	/** 
	 * Index of column COMMNUM
	 */
	protected static final int COLUMN_COMMNUM = 25;

	/** 
	 * Index of column CLIENTNO
	 */
	protected static final int COLUMN_CLIENTNO = 26;

	/** 
	 * Index of column CLIENTIDTYPE
	 */
	protected static final int COLUMN_CLIENTIDTYPE = 27;

	/** 
	 * Index of column CLIENTID
	 */
	protected static final int COLUMN_CLIENTID = 28;

	/** 
	 * Index of column CLIENTNAME
	 */
	protected static final int COLUMN_CLIENTNAME = 29;

	/** 
	 * Index of column PAYBACKACT
	 */
	protected static final int COLUMN_PAYBACKACT = 30;

	/** 
	 * Index of column PAYBACKACTNAME
	 */
	protected static final int COLUMN_PAYBACKACTNAME = 31;

	/** 
	 * Index of column PAYBACKBANKID
	 */
	protected static final int COLUMN_PAYBACKBANKID = 32;

	/** 
	 * Index of column PAYBACKBANKNO
	 */
	protected static final int COLUMN_PAYBACKBANKNO = 33;

	/** 
	 * Index of column PAYBACKBANKNAME
	 */
	protected static final int COLUMN_PAYBACKBANKNAME = 34;

	/** 
	 * Index of column CLIENTACT
	 */
	protected static final int COLUMN_CLIENTACT = 35;

	/** 
	 * Index of column OPERATORID
	 */
	protected static final int COLUMN_OPERATORID = 36;

	/** 
	 * Index of column OPERATEDATE
	 */
	protected static final int COLUMN_OPERATEDATE = 37;

	/** 
	 * Index of column CHECKERID
	 */
	protected static final int COLUMN_CHECKERID = 38;

	/** 
	 * Index of column CHECKDATE
	 */
	protected static final int COLUMN_CHECKDATE = 39;

	/** 
	 * Index of column REMARK
	 */
	protected static final int COLUMN_REMARK = 40;

	/** 
	 * Index of column CREATORID
	 */
	protected static final int COLUMN_CREATORID = 41;

	/** 
	 * Index of column CREATEDATE
	 */
	protected static final int COLUMN_CREATEDATE = 42;

	/** 
	 * Index of column CREATEFORM
	 */
	protected static final int COLUMN_CREATEFORM = 43;

	/** 
	 * Index of column UPDATORID
	 */
	protected static final int COLUMN_UPDATORID = 44;

	/** 
	 * Index of column UPDATEDATE
	 */
	protected static final int COLUMN_UPDATEDATE = 45;

	/** 
	 * Index of column UPDATEFORM
	 */
	protected static final int COLUMN_UPDATEFORM = 46;

	/** 
	 * Index of column CUSTOMER_CODE
	 */
	protected static final int COLUMN_CUSTOMER_CODE = 47;

	/** 
	 * Index of column SIGN_ACCOUNT_NO
	 */
	protected static final int COLUMN_SIGN_ACCOUNT_NO = 48;

	/** 
	 * Index of column RECEIVEAMT
	 */
	protected static final int COLUMN_RECEIVEAMT = 49;

	/** 
	 * Index of column WITHHOLDBANKNAME
	 */
	protected static final int COLUMN_WITHHOLDBANKNAME = 50;

	/** 
	 * Index of column COMMAMT
	 */
	protected static final int COLUMN_COMMAMT = 51;

	/** 
	 * Index of column TERMINALCD
	 */
	protected static final int COLUMN_TERMINALCD = 52;

	/** 
	 * Index of column TERMINALDATE
	 */
	protected static final int COLUMN_TERMINALDATE = 53;

	/** 
	 * Index of column TERMINALREASON
	 */
	protected static final int COLUMN_TERMINALREASON = 54;

	/** 
	 * Number of columns
	 */
	protected static final int NUMBER_OF_COLUMNS = 54;

	/** 
	 * Index of primary-key column CONTRACTNO
	 */
	protected static final int PK_COLUMN_CONTRACTNO = 1;

	/** 
	 * Inserts a new row in the XFCONTRACT table.
	 */
	public XfcontractPk insert(Xfcontract dto) throws XfcontractDaoException
	{
		long t1 = System.currentTimeMillis();
		// declare variables
		final boolean isConnSupplied = (userConn != null);
		Connection conn = null;
		PreparedStatement stmt = null;
		ResultSet rs = null;
		
		try {
			// get the user-specified connection or get a connection from the ResourceManager
			conn = isConnSupplied ? userConn : ResourceManager.getConnection();
		
			stmt = conn.prepareStatement( SQL_INSERT );
			int index = 1;
			stmt.setString( index++, dto.getAppno() );
			stmt.setString( index++, dto.getContractno() );
			stmt.setString( index++, dto.getApptype() );
			stmt.setString( index++, dto.getInteresttype() );
			stmt.setTimestamp(index++, dto.getStartdate()==null ? null : new java.sql.Timestamp( dto.getStartdate().getTime() ) );
			stmt.setString( index++, dto.getPlace() );
			stmt.setString( index++, dto.getContracttype() );
			stmt.setString( index++, dto.getCstatus() );
			stmt.setBigDecimal( index++, dto.getDuration() );
			stmt.setString( index++, dto.getCurno() );
			stmt.setBigDecimal( index++, dto.getContractamt() );
			stmt.setBigDecimal( index++, dto.getPrincipalamt() );
			stmt.setBigDecimal( index++, dto.getServicecharge() );
			stmt.setBigDecimal( index++, dto.getLatefeerate() );
			stmt.setBigDecimal( index++, dto.getBreachfeerate() );
			stmt.setBigDecimal( index++, dto.getManagerfeerate() );
			stmt.setBigDecimal( index++, dto.getLowestlatefee() );
			stmt.setString( index++, dto.getPartnername() );
			stmt.setString( index++, dto.getPartneract() );
			stmt.setString( index++, dto.getPartnerbankid() );
			stmt.setString( index++, dto.getPartnerbankno() );
			stmt.setString( index++, dto.getPartnerbankname() );
			stmt.setString( index++, dto.getCommname() );
			stmt.setString( index++, dto.getCommtype() );
			stmt.setString( index++, dto.getCommnum() );
			stmt.setString( index++, dto.getClientno() );
			stmt.setString( index++, dto.getClientidtype() );
			stmt.setString( index++, dto.getClientid() );
			stmt.setString( index++, dto.getClientname() );
			stmt.setString( index++, dto.getPaybackact() );
			stmt.setString( index++, dto.getPaybackactname() );
			stmt.setString( index++, dto.getPaybackbankid() );
			stmt.setString( index++, dto.getPaybackbankno() );
			stmt.setString( index++, dto.getPaybackbankname() );
			stmt.setString( index++, dto.getClientact() );
			stmt.setString( index++, dto.getOperatorid() );
			stmt.setTimestamp(index++, dto.getOperatedate()==null ? null : new java.sql.Timestamp( dto.getOperatedate().getTime() ) );
			stmt.setString( index++, dto.getCheckerid() );
			stmt.setTimestamp(index++, dto.getCheckdate()==null ? null : new java.sql.Timestamp( dto.getCheckdate().getTime() ) );
			stmt.setString( index++, dto.getRemark() );
			stmt.setString( index++, dto.getCreatorid() );
			stmt.setTimestamp(index++, dto.getCreatedate()==null ? null : new java.sql.Timestamp( dto.getCreatedate().getTime() ) );
			stmt.setString( index++, dto.getCreateform() );
			stmt.setString( index++, dto.getUpdatorid() );
			stmt.setTimestamp(index++, dto.getUpdatedate()==null ? null : new java.sql.Timestamp( dto.getUpdatedate().getTime() ) );
			stmt.setString( index++, dto.getUpdateform() );
			stmt.setString( index++, dto.getCustomerCode() );
			stmt.setString( index++, dto.getSignAccountNo() );
			stmt.setBigDecimal( index++, dto.getReceiveamt() );
			stmt.setString( index++, dto.getWithholdbankname() );
			stmt.setBigDecimal( index++, dto.getCommamt() );
			stmt.setString( index++, dto.getTerminalcd() );
			stmt.setTimestamp(index++, dto.getTerminaldate()==null ? null : new java.sql.Timestamp( dto.getTerminaldate().getTime() ) );
			stmt.setString( index++, dto.getTerminalreason() );
			if (logger.isDebugEnabled()) {
				logger.debug( "Executing " + SQL_INSERT + " with DTO: " + dto);
			}
		
			int rows = stmt.executeUpdate();
			long t2 = System.currentTimeMillis();
			if (logger.isDebugEnabled()) {
				logger.debug( rows + " rows affected (" + (t2-t1) + " ms)");
			}
		
			reset(dto);
			return dto.createPk();
		}
		catch (Exception _e) {
			logger.error( "Exception: " + _e.getMessage(), _e );
			throw new XfcontractDaoException( "Exception: " + _e.getMessage(), _e );
		}
		finally {
			ResourceManager.close(stmt);
			if (!isConnSupplied) {
				ResourceManager.close(conn);
			}
		
		}
		
	}

	/** 
	 * Updates a single row in the XFCONTRACT table.
	 */
	public void update(XfcontractPk pk, Xfcontract dto) throws XfcontractDaoException
	{
		long t1 = System.currentTimeMillis();
		// declare variables
		final boolean isConnSupplied = (userConn != null);
		Connection conn = null;
		PreparedStatement stmt = null;
		
		try {
			// get the user-specified connection or get a connection from the ResourceManager
			conn = isConnSupplied ? userConn : ResourceManager.getConnection();
		
			if (logger.isDebugEnabled()) {
				logger.debug( "Executing " + SQL_UPDATE + " with DTO: " + dto);
			}
		
			stmt = conn.prepareStatement( SQL_UPDATE );
			int index=1;
			stmt.setString( index++, dto.getAppno() );
			stmt.setString( index++, dto.getContractno() );
			stmt.setString( index++, dto.getApptype() );
			stmt.setString( index++, dto.getInteresttype() );
			stmt.setTimestamp(index++, dto.getStartdate()==null ? null : new java.sql.Timestamp( dto.getStartdate().getTime() ) );
			stmt.setString( index++, dto.getPlace() );
			stmt.setString( index++, dto.getContracttype() );
			stmt.setString( index++, dto.getCstatus() );
			stmt.setBigDecimal( index++, dto.getDuration() );
			stmt.setString( index++, dto.getCurno() );
			stmt.setBigDecimal( index++, dto.getContractamt() );
			stmt.setBigDecimal( index++, dto.getPrincipalamt() );
			stmt.setBigDecimal( index++, dto.getServicecharge() );
			stmt.setBigDecimal( index++, dto.getLatefeerate() );
			stmt.setBigDecimal( index++, dto.getBreachfeerate() );
			stmt.setBigDecimal( index++, dto.getManagerfeerate() );
			stmt.setBigDecimal( index++, dto.getLowestlatefee() );
			stmt.setString( index++, dto.getPartnername() );
			stmt.setString( index++, dto.getPartneract() );
			stmt.setString( index++, dto.getPartnerbankid() );
			stmt.setString( index++, dto.getPartnerbankno() );
			stmt.setString( index++, dto.getPartnerbankname() );
			stmt.setString( index++, dto.getCommname() );
			stmt.setString( index++, dto.getCommtype() );
			stmt.setString( index++, dto.getCommnum() );
			stmt.setString( index++, dto.getClientno() );
			stmt.setString( index++, dto.getClientidtype() );
			stmt.setString( index++, dto.getClientid() );
			stmt.setString( index++, dto.getClientname() );
			stmt.setString( index++, dto.getPaybackact() );
			stmt.setString( index++, dto.getPaybackactname() );
			stmt.setString( index++, dto.getPaybackbankid() );
			stmt.setString( index++, dto.getPaybackbankno() );
			stmt.setString( index++, dto.getPaybackbankname() );
			stmt.setString( index++, dto.getClientact() );
			stmt.setString( index++, dto.getOperatorid() );
			stmt.setTimestamp(index++, dto.getOperatedate()==null ? null : new java.sql.Timestamp( dto.getOperatedate().getTime() ) );
			stmt.setString( index++, dto.getCheckerid() );
			stmt.setTimestamp(index++, dto.getCheckdate()==null ? null : new java.sql.Timestamp( dto.getCheckdate().getTime() ) );
			stmt.setString( index++, dto.getRemark() );
			stmt.setString( index++, dto.getCreatorid() );
			stmt.setTimestamp(index++, dto.getCreatedate()==null ? null : new java.sql.Timestamp( dto.getCreatedate().getTime() ) );
			stmt.setString( index++, dto.getCreateform() );
			stmt.setString( index++, dto.getUpdatorid() );
			stmt.setTimestamp(index++, dto.getUpdatedate()==null ? null : new java.sql.Timestamp( dto.getUpdatedate().getTime() ) );
			stmt.setString( index++, dto.getUpdateform() );
			stmt.setString( index++, dto.getCustomerCode() );
			stmt.setString( index++, dto.getSignAccountNo() );
			stmt.setBigDecimal( index++, dto.getReceiveamt() );
			stmt.setString( index++, dto.getWithholdbankname() );
			stmt.setBigDecimal( index++, dto.getCommamt() );
			stmt.setString( index++, dto.getTerminalcd() );
			stmt.setTimestamp(index++, dto.getTerminaldate()==null ? null : new java.sql.Timestamp( dto.getTerminaldate().getTime() ) );
			stmt.setString( index++, dto.getTerminalreason() );
			stmt.setString( 55, pk.getContractno() );
			int rows = stmt.executeUpdate();
			reset(dto);
			long t2 = System.currentTimeMillis();
			if (logger.isDebugEnabled()) {
				logger.debug( rows + " rows affected (" + (t2-t1) + " ms)");
			}
		
		}
		catch (Exception _e) {
			logger.error( "Exception: " + _e.getMessage(), _e );
			throw new XfcontractDaoException( "Exception: " + _e.getMessage(), _e );
		}
		finally {
			ResourceManager.close(stmt);
			if (!isConnSupplied) {
				ResourceManager.close(conn);
			}
		
		}
		
	}

	/** 
	 * Deletes a single row in the XFCONTRACT table.
	 */
	public void delete(XfcontractPk pk) throws XfcontractDaoException
	{
		long t1 = System.currentTimeMillis();
		// declare variables
		final boolean isConnSupplied = (userConn != null);
		Connection conn = null;
		PreparedStatement stmt = null;
		
		try {
			// get the user-specified connection or get a connection from the ResourceManager
			conn = isConnSupplied ? userConn : ResourceManager.getConnection();
		
			if (logger.isDebugEnabled()) {
				logger.debug( "Executing " + SQL_DELETE + " with PK: " + pk);
			}
		
			stmt = conn.prepareStatement( SQL_DELETE );
			stmt.setString( 1, pk.getContractno() );
			int rows = stmt.executeUpdate();
			long t2 = System.currentTimeMillis();
			if (logger.isDebugEnabled()) {
				logger.debug( rows + " rows affected (" + (t2-t1) + " ms)");
			}
		
		}
		catch (Exception _e) {
			logger.error( "Exception: " + _e.getMessage(), _e );
			throw new XfcontractDaoException( "Exception: " + _e.getMessage(), _e );
		}
		finally {
			ResourceManager.close(stmt);
			if (!isConnSupplied) {
				ResourceManager.close(conn);
			}
		
		}
		
	}

	/** 
	 * Returns the rows from the XFCONTRACT table that matches the specified primary-key value.
	 */
	public Xfcontract findByPrimaryKey(XfcontractPk pk) throws XfcontractDaoException
	{
		return findByPrimaryKey( pk.getContractno() );
	}

	/** 
	 * Returns all rows from the XFCONTRACT table that match the criteria 'CONTRACTNO = :contractno'.
	 */
	public Xfcontract findByPrimaryKey(String contractno) throws XfcontractDaoException
	{
		Xfcontract ret[] = findByDynamicSelect( SQL_SELECT + " WHERE CONTRACTNO = ?", new Object[] { contractno } );
		return ret.length==0 ? null : ret[0];
	}

	/** 
	 * Returns all rows from the XFCONTRACT table that match the criteria 'ACTPAYDATE = :actpaydate'.
	 */
	public Xfcontract[] findWhereActpaydateEquals(Date actpaydate) throws XfcontractDaoException
	{
		return findByDynamicSelect( SQL_SELECT + " WHERE ACTPAYDATE = ? ORDER BY ACTPAYDATE", new Object[] { actpaydate==null ? null : new java.sql.Timestamp( actpaydate.getTime() ) } );
	}

	/** 
	 * Returns all rows from the XFCONTRACT table that match the criteria 'SELLERSERVICECHARGE = :sellerservicecharge'.
	 */
	public Xfcontract[] findWhereSellerservicechargeEquals(BigDecimal sellerservicecharge) throws XfcontractDaoException
	{
		return findByDynamicSelect( SQL_SELECT + " WHERE SELLERSERVICECHARGE = ? ORDER BY SELLERSERVICECHARGE", new Object[] { sellerservicecharge } );
	}

	/** 
	 * Returns all rows from the XFCONTRACT table that match the criteria 'BUYERSERVICECHARGE = :buyerservicecharge'.
	 */
	public Xfcontract[] findWhereBuyerservicechargeEquals(BigDecimal buyerservicecharge) throws XfcontractDaoException
	{
		return findByDynamicSelect( SQL_SELECT + " WHERE BUYERSERVICECHARGE = ? ORDER BY BUYERSERVICECHARGE", new Object[] { buyerservicecharge } );
	}

	/** 
	 * Returns all rows from the XFCONTRACT table that match the criteria 'ACTPAYAMT = :actpayamt'.
	 */
	public Xfcontract[] findWhereActpayamtEquals(BigDecimal actpayamt) throws XfcontractDaoException
	{
		return findByDynamicSelect( SQL_SELECT + " WHERE ACTPAYAMT = ? ORDER BY ACTPAYAMT", new Object[] { actpayamt } );
	}

	/** 
	 * Returns all rows from the XFCONTRACT table that match the criteria ''.
	 */
	public Xfcontract[] findAll() throws XfcontractDaoException
	{
		return findByDynamicSelect( SQL_SELECT + " ORDER BY CONTRACTNO", null );
	}

	/** 
	 * Returns all rows from the XFCONTRACT table that match the criteria 'APPNO = :appno'.
	 */
	public Xfcontract[] findWhereAppnoEquals(String appno) throws XfcontractDaoException
	{
		return findByDynamicSelect( SQL_SELECT + " WHERE APPNO = ? ORDER BY APPNO", new Object[] { appno } );
	}

	/** 
	 * Returns all rows from the XFCONTRACT table that match the criteria 'CONTRACTNO = :contractno'.
	 */
	public Xfcontract[] findWhereContractnoEquals(String contractno) throws XfcontractDaoException
	{
		return findByDynamicSelect( SQL_SELECT + " WHERE CONTRACTNO = ? ORDER BY CONTRACTNO", new Object[] { contractno } );
	}

	/** 
	 * Returns all rows from the XFCONTRACT table that match the criteria 'APPTYPE = :apptype'.
	 */
	public Xfcontract[] findWhereApptypeEquals(String apptype) throws XfcontractDaoException
	{
		return findByDynamicSelect( SQL_SELECT + " WHERE APPTYPE = ? ORDER BY APPTYPE", new Object[] { apptype } );
	}

	/** 
	 * Returns all rows from the XFCONTRACT table that match the criteria 'INTERESTTYPE = :interesttype'.
	 */
	public Xfcontract[] findWhereInteresttypeEquals(String interesttype) throws XfcontractDaoException
	{
		return findByDynamicSelect( SQL_SELECT + " WHERE INTERESTTYPE = ? ORDER BY INTERESTTYPE", new Object[] { interesttype } );
	}

	/** 
	 * Returns all rows from the XFCONTRACT table that match the criteria 'STARTDATE = :startdate'.
	 */
	public Xfcontract[] findWhereStartdateEquals(Date startdate) throws XfcontractDaoException
	{
		return findByDynamicSelect( SQL_SELECT + " WHERE STARTDATE = ? ORDER BY STARTDATE", new Object[] { startdate==null ? null : new java.sql.Timestamp( startdate.getTime() ) } );
	}

	/** 
	 * Returns all rows from the XFCONTRACT table that match the criteria 'PLACE = :place'.
	 */
	public Xfcontract[] findWherePlaceEquals(String place) throws XfcontractDaoException
	{
		return findByDynamicSelect( SQL_SELECT + " WHERE PLACE = ? ORDER BY PLACE", new Object[] { place } );
	}

	/** 
	 * Returns all rows from the XFCONTRACT table that match the criteria 'CONTRACTTYPE = :contracttype'.
	 */
	public Xfcontract[] findWhereContracttypeEquals(String contracttype) throws XfcontractDaoException
	{
		return findByDynamicSelect( SQL_SELECT + " WHERE CONTRACTTYPE = ? ORDER BY CONTRACTTYPE", new Object[] { contracttype } );
	}

	/** 
	 * Returns all rows from the XFCONTRACT table that match the criteria 'CSTATUS = :cstatus'.
	 */
	public Xfcontract[] findWhereCstatusEquals(String cstatus) throws XfcontractDaoException
	{
		return findByDynamicSelect( SQL_SELECT + " WHERE CSTATUS = ? ORDER BY CSTATUS", new Object[] { cstatus } );
	}

	/** 
	 * Returns all rows from the XFCONTRACT table that match the criteria 'DURATION = :duration'.
	 */
	public Xfcontract[] findWhereDurationEquals(BigDecimal duration) throws XfcontractDaoException
	{
		return findByDynamicSelect( SQL_SELECT + " WHERE DURATION = ? ORDER BY DURATION", new Object[] { duration } );
	}

	/** 
	 * Returns all rows from the XFCONTRACT table that match the criteria 'CURNO = :curno'.
	 */
	public Xfcontract[] findWhereCurnoEquals(String curno) throws XfcontractDaoException
	{
		return findByDynamicSelect( SQL_SELECT + " WHERE CURNO = ? ORDER BY CURNO", new Object[] { curno } );
	}

	/** 
	 * Returns all rows from the XFCONTRACT table that match the criteria 'CONTRACTAMT = :contractamt'.
	 */
	public Xfcontract[] findWhereContractamtEquals(BigDecimal contractamt) throws XfcontractDaoException
	{
		return findByDynamicSelect( SQL_SELECT + " WHERE CONTRACTAMT = ? ORDER BY CONTRACTAMT", new Object[] { contractamt } );
	}

	/** 
	 * Returns all rows from the XFCONTRACT table that match the criteria 'PRINCIPALAMT = :principalamt'.
	 */
	public Xfcontract[] findWherePrincipalamtEquals(BigDecimal principalamt) throws XfcontractDaoException
	{
		return findByDynamicSelect( SQL_SELECT + " WHERE PRINCIPALAMT = ? ORDER BY PRINCIPALAMT", new Object[] { principalamt } );
	}

	/** 
	 * Returns all rows from the XFCONTRACT table that match the criteria 'SERVICECHARGE = :servicecharge'.
	 */
	public Xfcontract[] findWhereServicechargeEquals(BigDecimal servicecharge) throws XfcontractDaoException
	{
		return findByDynamicSelect( SQL_SELECT + " WHERE SERVICECHARGE = ? ORDER BY SERVICECHARGE", new Object[] { servicecharge } );
	}

	/** 
	 * Returns all rows from the XFCONTRACT table that match the criteria 'LATEFEERATE = :latefeerate'.
	 */
	public Xfcontract[] findWhereLatefeerateEquals(BigDecimal latefeerate) throws XfcontractDaoException
	{
		return findByDynamicSelect( SQL_SELECT + " WHERE LATEFEERATE = ? ORDER BY LATEFEERATE", new Object[] { latefeerate } );
	}

	/** 
	 * Returns all rows from the XFCONTRACT table that match the criteria 'BREACHFEERATE = :breachfeerate'.
	 */
	public Xfcontract[] findWhereBreachfeerateEquals(BigDecimal breachfeerate) throws XfcontractDaoException
	{
		return findByDynamicSelect( SQL_SELECT + " WHERE BREACHFEERATE = ? ORDER BY BREACHFEERATE", new Object[] { breachfeerate } );
	}

	/** 
	 * Returns all rows from the XFCONTRACT table that match the criteria 'MANAGERFEERATE = :managerfeerate'.
	 */
	public Xfcontract[] findWhereManagerfeerateEquals(BigDecimal managerfeerate) throws XfcontractDaoException
	{
		return findByDynamicSelect( SQL_SELECT + " WHERE MANAGERFEERATE = ? ORDER BY MANAGERFEERATE", new Object[] { managerfeerate } );
	}

	/** 
	 * Returns all rows from the XFCONTRACT table that match the criteria 'LOWESTLATEFEE = :lowestlatefee'.
	 */
	public Xfcontract[] findWhereLowestlatefeeEquals(BigDecimal lowestlatefee) throws XfcontractDaoException
	{
		return findByDynamicSelect( SQL_SELECT + " WHERE LOWESTLATEFEE = ? ORDER BY LOWESTLATEFEE", new Object[] { lowestlatefee } );
	}

	/** 
	 * Returns all rows from the XFCONTRACT table that match the criteria 'PARTNERNAME = :partnername'.
	 */
	public Xfcontract[] findWherePartnernameEquals(String partnername) throws XfcontractDaoException
	{
		return findByDynamicSelect( SQL_SELECT + " WHERE PARTNERNAME = ? ORDER BY PARTNERNAME", new Object[] { partnername } );
	}

	/** 
	 * Returns all rows from the XFCONTRACT table that match the criteria 'PARTNERACT = :partneract'.
	 */
	public Xfcontract[] findWherePartneractEquals(String partneract) throws XfcontractDaoException
	{
		return findByDynamicSelect( SQL_SELECT + " WHERE PARTNERACT = ? ORDER BY PARTNERACT", new Object[] { partneract } );
	}

	/** 
	 * Returns all rows from the XFCONTRACT table that match the criteria 'PARTNERBANKID = :partnerbankid'.
	 */
	public Xfcontract[] findWherePartnerbankidEquals(String partnerbankid) throws XfcontractDaoException
	{
		return findByDynamicSelect( SQL_SELECT + " WHERE PARTNERBANKID = ? ORDER BY PARTNERBANKID", new Object[] { partnerbankid } );
	}

	/** 
	 * Returns all rows from the XFCONTRACT table that match the criteria 'PARTNERBANKNO = :partnerbankno'.
	 */
	public Xfcontract[] findWherePartnerbanknoEquals(String partnerbankno) throws XfcontractDaoException
	{
		return findByDynamicSelect( SQL_SELECT + " WHERE PARTNERBANKNO = ? ORDER BY PARTNERBANKNO", new Object[] { partnerbankno } );
	}

	/** 
	 * Returns all rows from the XFCONTRACT table that match the criteria 'PARTNERBANKNAME = :partnerbankname'.
	 */
	public Xfcontract[] findWherePartnerbanknameEquals(String partnerbankname) throws XfcontractDaoException
	{
		return findByDynamicSelect( SQL_SELECT + " WHERE PARTNERBANKNAME = ? ORDER BY PARTNERBANKNAME", new Object[] { partnerbankname } );
	}

	/** 
	 * Returns all rows from the XFCONTRACT table that match the criteria 'COMMNAME = :commname'.
	 */
	public Xfcontract[] findWhereCommnameEquals(String commname) throws XfcontractDaoException
	{
		return findByDynamicSelect( SQL_SELECT + " WHERE COMMNAME = ? ORDER BY COMMNAME", new Object[] { commname } );
	}

	/** 
	 * Returns all rows from the XFCONTRACT table that match the criteria 'COMMTYPE = :commtype'.
	 */
	public Xfcontract[] findWhereCommtypeEquals(String commtype) throws XfcontractDaoException
	{
		return findByDynamicSelect( SQL_SELECT + " WHERE COMMTYPE = ? ORDER BY COMMTYPE", new Object[] { commtype } );
	}

	/** 
	 * Returns all rows from the XFCONTRACT table that match the criteria 'COMMNUM = :commnum'.
	 */
	public Xfcontract[] findWhereCommnumEquals(String commnum) throws XfcontractDaoException
	{
		return findByDynamicSelect( SQL_SELECT + " WHERE COMMNUM = ? ORDER BY COMMNUM", new Object[] { commnum } );
	}

	/** 
	 * Returns all rows from the XFCONTRACT table that match the criteria 'CLIENTNO = :clientno'.
	 */
	public Xfcontract[] findWhereClientnoEquals(String clientno) throws XfcontractDaoException
	{
		return findByDynamicSelect( SQL_SELECT + " WHERE CLIENTNO = ? ORDER BY CLIENTNO", new Object[] { clientno } );
	}

	/** 
	 * Returns all rows from the XFCONTRACT table that match the criteria 'CLIENTIDTYPE = :clientidtype'.
	 */
	public Xfcontract[] findWhereClientidtypeEquals(String clientidtype) throws XfcontractDaoException
	{
		return findByDynamicSelect( SQL_SELECT + " WHERE CLIENTIDTYPE = ? ORDER BY CLIENTIDTYPE", new Object[] { clientidtype } );
	}

	/** 
	 * Returns all rows from the XFCONTRACT table that match the criteria 'CLIENTID = :clientid'.
	 */
	public Xfcontract[] findWhereClientidEquals(String clientid) throws XfcontractDaoException
	{
		return findByDynamicSelect( SQL_SELECT + " WHERE CLIENTID = ? ORDER BY CLIENTID", new Object[] { clientid } );
	}

	/** 
	 * Returns all rows from the XFCONTRACT table that match the criteria 'CLIENTNAME = :clientname'.
	 */
	public Xfcontract[] findWhereClientnameEquals(String clientname) throws XfcontractDaoException
	{
		return findByDynamicSelect( SQL_SELECT + " WHERE CLIENTNAME = ? ORDER BY CLIENTNAME", new Object[] { clientname } );
	}

	/** 
	 * Returns all rows from the XFCONTRACT table that match the criteria 'PAYBACKACT = :paybackact'.
	 */
	public Xfcontract[] findWherePaybackactEquals(String paybackact) throws XfcontractDaoException
	{
		return findByDynamicSelect( SQL_SELECT + " WHERE PAYBACKACT = ? ORDER BY PAYBACKACT", new Object[] { paybackact } );
	}

	/** 
	 * Returns all rows from the XFCONTRACT table that match the criteria 'PAYBACKACTNAME = :paybackactname'.
	 */
	public Xfcontract[] findWherePaybackactnameEquals(String paybackactname) throws XfcontractDaoException
	{
		return findByDynamicSelect( SQL_SELECT + " WHERE PAYBACKACTNAME = ? ORDER BY PAYBACKACTNAME", new Object[] { paybackactname } );
	}

	/** 
	 * Returns all rows from the XFCONTRACT table that match the criteria 'PAYBACKBANKID = :paybackbankid'.
	 */
	public Xfcontract[] findWherePaybackbankidEquals(String paybackbankid) throws XfcontractDaoException
	{
		return findByDynamicSelect( SQL_SELECT + " WHERE PAYBACKBANKID = ? ORDER BY PAYBACKBANKID", new Object[] { paybackbankid } );
	}

	/** 
	 * Returns all rows from the XFCONTRACT table that match the criteria 'PAYBACKBANKNO = :paybackbankno'.
	 */
	public Xfcontract[] findWherePaybackbanknoEquals(String paybackbankno) throws XfcontractDaoException
	{
		return findByDynamicSelect( SQL_SELECT + " WHERE PAYBACKBANKNO = ? ORDER BY PAYBACKBANKNO", new Object[] { paybackbankno } );
	}

	/** 
	 * Returns all rows from the XFCONTRACT table that match the criteria 'PAYBACKBANKNAME = :paybackbankname'.
	 */
	public Xfcontract[] findWherePaybackbanknameEquals(String paybackbankname) throws XfcontractDaoException
	{
		return findByDynamicSelect( SQL_SELECT + " WHERE PAYBACKBANKNAME = ? ORDER BY PAYBACKBANKNAME", new Object[] { paybackbankname } );
	}

	/** 
	 * Returns all rows from the XFCONTRACT table that match the criteria 'CLIENTACT = :clientact'.
	 */
	public Xfcontract[] findWhereClientactEquals(String clientact) throws XfcontractDaoException
	{
		return findByDynamicSelect( SQL_SELECT + " WHERE CLIENTACT = ? ORDER BY CLIENTACT", new Object[] { clientact } );
	}

	/** 
	 * Returns all rows from the XFCONTRACT table that match the criteria 'OPERATORID = :operatorid'.
	 */
	public Xfcontract[] findWhereOperatoridEquals(String operatorid) throws XfcontractDaoException
	{
		return findByDynamicSelect( SQL_SELECT + " WHERE OPERATORID = ? ORDER BY OPERATORID", new Object[] { operatorid } );
	}

	/** 
	 * Returns all rows from the XFCONTRACT table that match the criteria 'OPERATEDATE = :operatedate'.
	 */
	public Xfcontract[] findWhereOperatedateEquals(Date operatedate) throws XfcontractDaoException
	{
		return findByDynamicSelect( SQL_SELECT + " WHERE OPERATEDATE = ? ORDER BY OPERATEDATE", new Object[] { operatedate==null ? null : new java.sql.Timestamp( operatedate.getTime() ) } );
	}

	/** 
	 * Returns all rows from the XFCONTRACT table that match the criteria 'CHECKERID = :checkerid'.
	 */
	public Xfcontract[] findWhereCheckeridEquals(String checkerid) throws XfcontractDaoException
	{
		return findByDynamicSelect( SQL_SELECT + " WHERE CHECKERID = ? ORDER BY CHECKERID", new Object[] { checkerid } );
	}

	/** 
	 * Returns all rows from the XFCONTRACT table that match the criteria 'CHECKDATE = :checkdate'.
	 */
	public Xfcontract[] findWhereCheckdateEquals(Date checkdate) throws XfcontractDaoException
	{
		return findByDynamicSelect( SQL_SELECT + " WHERE CHECKDATE = ? ORDER BY CHECKDATE", new Object[] { checkdate==null ? null : new java.sql.Timestamp( checkdate.getTime() ) } );
	}

	/** 
	 * Returns all rows from the XFCONTRACT table that match the criteria 'REMARK = :remark'.
	 */
	public Xfcontract[] findWhereRemarkEquals(String remark) throws XfcontractDaoException
	{
		return findByDynamicSelect( SQL_SELECT + " WHERE REMARK = ? ORDER BY REMARK", new Object[] { remark } );
	}

	/** 
	 * Returns all rows from the XFCONTRACT table that match the criteria 'CREATORID = :creatorid'.
	 */
	public Xfcontract[] findWhereCreatoridEquals(String creatorid) throws XfcontractDaoException
	{
		return findByDynamicSelect( SQL_SELECT + " WHERE CREATORID = ? ORDER BY CREATORID", new Object[] { creatorid } );
	}

	/** 
	 * Returns all rows from the XFCONTRACT table that match the criteria 'CREATEDATE = :createdate'.
	 */
	public Xfcontract[] findWhereCreatedateEquals(Date createdate) throws XfcontractDaoException
	{
		return findByDynamicSelect( SQL_SELECT + " WHERE CREATEDATE = ? ORDER BY CREATEDATE", new Object[] { createdate==null ? null : new java.sql.Timestamp( createdate.getTime() ) } );
	}

	/** 
	 * Returns all rows from the XFCONTRACT table that match the criteria 'CREATEFORM = :createform'.
	 */
	public Xfcontract[] findWhereCreateformEquals(String createform) throws XfcontractDaoException
	{
		return findByDynamicSelect( SQL_SELECT + " WHERE CREATEFORM = ? ORDER BY CREATEFORM", new Object[] { createform } );
	}

	/** 
	 * Returns all rows from the XFCONTRACT table that match the criteria 'UPDATORID = :updatorid'.
	 */
	public Xfcontract[] findWhereUpdatoridEquals(String updatorid) throws XfcontractDaoException
	{
		return findByDynamicSelect( SQL_SELECT + " WHERE UPDATORID = ? ORDER BY UPDATORID", new Object[] { updatorid } );
	}

	/** 
	 * Returns all rows from the XFCONTRACT table that match the criteria 'UPDATEDATE = :updatedate'.
	 */
	public Xfcontract[] findWhereUpdatedateEquals(Date updatedate) throws XfcontractDaoException
	{
		return findByDynamicSelect( SQL_SELECT + " WHERE UPDATEDATE = ? ORDER BY UPDATEDATE", new Object[] { updatedate==null ? null : new java.sql.Timestamp( updatedate.getTime() ) } );
	}

	/** 
	 * Returns all rows from the XFCONTRACT table that match the criteria 'UPDATEFORM = :updateform'.
	 */
	public Xfcontract[] findWhereUpdateformEquals(String updateform) throws XfcontractDaoException
	{
		return findByDynamicSelect( SQL_SELECT + " WHERE UPDATEFORM = ? ORDER BY UPDATEFORM", new Object[] { updateform } );
	}

	/** 
	 * Returns all rows from the XFCONTRACT table that match the criteria 'CUSTOMER_CODE = :customerCode'.
	 */
	public Xfcontract[] findWhereCustomerCodeEquals(String customerCode) throws XfcontractDaoException
	{
		return findByDynamicSelect( SQL_SELECT + " WHERE CUSTOMER_CODE = ? ORDER BY CUSTOMER_CODE", new Object[] { customerCode } );
	}

	/** 
	 * Returns all rows from the XFCONTRACT table that match the criteria 'SIGN_ACCOUNT_NO = :signAccountNo'.
	 */
	public Xfcontract[] findWhereSignAccountNoEquals(String signAccountNo) throws XfcontractDaoException
	{
		return findByDynamicSelect( SQL_SELECT + " WHERE SIGN_ACCOUNT_NO = ? ORDER BY SIGN_ACCOUNT_NO", new Object[] { signAccountNo } );
	}

	/** 
	 * Returns all rows from the XFCONTRACT table that match the criteria 'COMMAMT = :commamt'.
	 */
	public Xfcontract[] findWhereCommamtEquals(BigDecimal commamt) throws XfcontractDaoException
	{
		return findByDynamicSelect( SQL_SELECT + " WHERE COMMAMT = ? ORDER BY COMMAMT", new Object[] { commamt } );
	}

	/** 
	 * Returns all rows from the XFCONTRACT table that match the criteria 'RECEIVEAMT = :receiveamt'.
	 */
	public Xfcontract[] findWhereReceiveamtEquals(BigDecimal receiveamt) throws XfcontractDaoException
	{
		return findByDynamicSelect( SQL_SELECT + " WHERE RECEIVEAMT = ? ORDER BY RECEIVEAMT", new Object[] { receiveamt } );
	}

	/** 
	 * Returns all rows from the XFCONTRACT table that match the criteria 'WITHHOLDBANKNAME = :withholdbankname'.
	 */
	public Xfcontract[] findWhereWithholdbanknameEquals(String withholdbankname) throws XfcontractDaoException
	{
		return findByDynamicSelect( SQL_SELECT + " WHERE WITHHOLDBANKNAME = ? ORDER BY WITHHOLDBANKNAME", new Object[] { withholdbankname } );
	}

	/** 
	 * Returns all rows from the XFCONTRACT table that match the criteria 'TERMINALCD = :terminalcd'.
	 */
	public Xfcontract[] findWhereTerminalcdEquals(String terminalcd) throws XfcontractDaoException
	{
		return findByDynamicSelect( SQL_SELECT + " WHERE TERMINALCD = ? ORDER BY TERMINALCD", new Object[] { terminalcd } );
	}

	/** 
	 * Returns all rows from the XFCONTRACT table that match the criteria 'TERMINALDATE = :terminaldate'.
	 */
	public Xfcontract[] findWhereTerminaldateEquals(Date terminaldate) throws XfcontractDaoException
	{
		return findByDynamicSelect( SQL_SELECT + " WHERE TERMINALDATE = ? ORDER BY TERMINALDATE", new Object[] { terminaldate==null ? null : new java.sql.Timestamp( terminaldate.getTime() ) } );
	}

	/** 
	 * Returns all rows from the XFCONTRACT table that match the criteria 'TERMINALREASON = :terminalreason'.
	 */
	public Xfcontract[] findWhereTerminalreasonEquals(String terminalreason) throws XfcontractDaoException
	{
		return findByDynamicSelect( SQL_SELECT + " WHERE TERMINALREASON = ? ORDER BY TERMINALREASON", new Object[] { terminalreason } );
	}

	/**
	 * Method 'XfcontractDaoImpl'
	 * 
	 */
	public XfcontractDaoImpl()
	{
	}

	/**
	 * Method 'XfcontractDaoImpl'
	 * 
	 * @param userConn
	 */
	public XfcontractDaoImpl(final java.sql.Connection userConn)
	{
		this.userConn = userConn;
	}

	/** 
	 * Sets the value of maxRows
	 */
	public void setMaxRows(int maxRows)
	{
		this.maxRows = maxRows;
	}

	/** 
	 * Gets the value of maxRows
	 */
	public int getMaxRows()
	{
		return maxRows;
	}

	/**
	 * Method 'getTableName'
	 * 
	 * @return String
	 */
	public String getTableName()
	{
		return "CMS.XFCONTRACT";
	}

	/** 
	 * Fetches a single row from the result set
	 */
	protected Xfcontract fetchSingleResult(ResultSet rs) throws SQLException
	{
		if (rs.next()) {
			Xfcontract dto = new Xfcontract();
			populateDto( dto, rs);
			return dto;
		} else {
			return null;
		}
		
	}

	/** 
	 * Fetches multiple rows from the result set
	 */
	protected Xfcontract[] fetchMultiResults(ResultSet rs) throws SQLException
	{
		Collection resultList = new ArrayList();
		while (rs.next()) {
			Xfcontract dto = new Xfcontract();
			populateDto( dto, rs);
			resultList.add( dto );
		}
		
		Xfcontract ret[] = new Xfcontract[ resultList.size() ];
		resultList.toArray( ret );
		return ret;
	}

	/** 
	 * Populates a DTO with data from a ResultSet
	 */
	protected void populateDto(Xfcontract dto, ResultSet rs) throws SQLException
	{
		dto.setAppno( rs.getString( COLUMN_APPNO ) );
		dto.setContractno( rs.getString( COLUMN_CONTRACTNO ) );
		dto.setApptype( rs.getString( COLUMN_APPTYPE ) );
		dto.setInteresttype( rs.getString( COLUMN_INTERESTTYPE ) );
		dto.setStartdate( rs.getTimestamp(COLUMN_STARTDATE ) );
		dto.setPlace( rs.getString( COLUMN_PLACE ) );
		dto.setContracttype( rs.getString( COLUMN_CONTRACTTYPE ) );
		dto.setCstatus( rs.getString( COLUMN_CSTATUS ) );
		dto.setDuration( rs.getBigDecimal(COLUMN_DURATION));
		dto.setCurno( rs.getString( COLUMN_CURNO ) );
		dto.setContractamt( rs.getBigDecimal(COLUMN_CONTRACTAMT));
		dto.setPrincipalamt( rs.getBigDecimal(COLUMN_PRINCIPALAMT));
		dto.setServicecharge( rs.getBigDecimal(COLUMN_SERVICECHARGE));
		dto.setLatefeerate( rs.getBigDecimal(COLUMN_LATEFEERATE));
		dto.setBreachfeerate( rs.getBigDecimal(COLUMN_BREACHFEERATE));
		dto.setManagerfeerate( rs.getBigDecimal(COLUMN_MANAGERFEERATE));
		dto.setLowestlatefee( rs.getBigDecimal(COLUMN_LOWESTLATEFEE));
		dto.setPartnername( rs.getString( COLUMN_PARTNERNAME ) );
		dto.setPartneract( rs.getString( COLUMN_PARTNERACT ) );
		dto.setPartnerbankid( rs.getString( COLUMN_PARTNERBANKID ) );
		dto.setPartnerbankno( rs.getString( COLUMN_PARTNERBANKNO ) );
		dto.setPartnerbankname( rs.getString( COLUMN_PARTNERBANKNAME ) );
		dto.setCommname( rs.getString( COLUMN_COMMNAME ) );
		dto.setCommtype( rs.getString( COLUMN_COMMTYPE ) );
		dto.setCommnum( rs.getString( COLUMN_COMMNUM ) );
		dto.setClientno( rs.getString( COLUMN_CLIENTNO ) );
		dto.setClientidtype( rs.getString( COLUMN_CLIENTIDTYPE ) );
		dto.setClientid( rs.getString( COLUMN_CLIENTID ) );
		dto.setClientname( rs.getString( COLUMN_CLIENTNAME ) );
		dto.setPaybackact( rs.getString( COLUMN_PAYBACKACT ) );
		dto.setPaybackactname( rs.getString( COLUMN_PAYBACKACTNAME ) );
		dto.setPaybackbankid( rs.getString( COLUMN_PAYBACKBANKID ) );
		dto.setPaybackbankno( rs.getString( COLUMN_PAYBACKBANKNO ) );
		dto.setPaybackbankname( rs.getString( COLUMN_PAYBACKBANKNAME ) );
		dto.setClientact( rs.getString( COLUMN_CLIENTACT ) );
		dto.setOperatorid( rs.getString( COLUMN_OPERATORID ) );
		dto.setOperatedate( rs.getTimestamp(COLUMN_OPERATEDATE ) );
		dto.setCheckerid( rs.getString( COLUMN_CHECKERID ) );
		dto.setCheckdate( rs.getTimestamp(COLUMN_CHECKDATE ) );
		dto.setRemark( rs.getString( COLUMN_REMARK ) );
		dto.setCreatorid( rs.getString( COLUMN_CREATORID ) );
		dto.setCreatedate( rs.getTimestamp(COLUMN_CREATEDATE ) );
		dto.setCreateform( rs.getString( COLUMN_CREATEFORM ) );
		dto.setUpdatorid( rs.getString( COLUMN_UPDATORID ) );
		dto.setUpdatedate( rs.getTimestamp(COLUMN_UPDATEDATE ) );
		dto.setUpdateform( rs.getString( COLUMN_UPDATEFORM ) );
		dto.setCustomerCode( rs.getString( COLUMN_CUSTOMER_CODE ) );
		dto.setSignAccountNo( rs.getString( COLUMN_SIGN_ACCOUNT_NO ) );
		dto.setReceiveamt( rs.getBigDecimal(COLUMN_RECEIVEAMT));
		dto.setWithholdbankname( rs.getString( COLUMN_WITHHOLDBANKNAME ) );
		dto.setCommamt( rs.getBigDecimal(COLUMN_COMMAMT));
		dto.setTerminalcd( rs.getString( COLUMN_TERMINALCD ) );
		dto.setTerminaldate( rs.getTimestamp(COLUMN_TERMINALDATE ) );
		dto.setTerminalreason( rs.getString( COLUMN_TERMINALREASON ) );
	}

	/** 
	 * Resets the modified attributes in the DTO
	 */
	protected void reset(Xfcontract dto)
	{
	}

	/** 
	 * Returns all rows from the XFCONTRACT table that match the specified arbitrary SQL statement
	 */
	public Xfcontract[] findByDynamicSelect(String sql, Object[] sqlParams) throws XfcontractDaoException
	{
		// declare variables
		final boolean isConnSupplied = (userConn != null);
		Connection conn = null;
		PreparedStatement stmt = null;
		ResultSet rs = null;
		
		try {
			// get the user-specified connection or get a connection from the ResourceManager
			conn = isConnSupplied ? userConn : ResourceManager.getConnection();
		
			// construct the SQL statement
			final String SQL = sql;
		
		
			if (logger.isDebugEnabled()) {
				logger.debug( "Executing " + SQL);
			}
		
			// prepare statement
			stmt = conn.prepareStatement( SQL );
			stmt.setMaxRows( maxRows );
		
			// bind parameters
			for (int i=0; sqlParams!=null && i<sqlParams.length; i++ ) {
				stmt.setObject( i+1, sqlParams[i] );
			}
		
		
			rs = stmt.executeQuery();
		
			// fetch the results
			return fetchMultiResults(rs);
		}
		catch (Exception _e) {
			logger.error( "Exception: " + _e.getMessage(), _e );
			throw new XfcontractDaoException( "Exception: " + _e.getMessage(), _e );
		}
		finally {
			ResourceManager.close(rs);
			ResourceManager.close(stmt);
			if (!isConnSupplied) {
				ResourceManager.close(conn);
			}
		
		}
		
	}

	/** 
	 * Returns all rows from the XFCONTRACT table that match the specified arbitrary SQL statement
	 */
	public Xfcontract[] findByDynamicWhere(String sql, Object[] sqlParams) throws XfcontractDaoException
	{
		// declare variables
		final boolean isConnSupplied = (userConn != null);
		Connection conn = null;
		PreparedStatement stmt = null;
		ResultSet rs = null;
		
		try {
			// get the user-specified connection or get a connection from the ResourceManager
			conn = isConnSupplied ? userConn : ResourceManager.getConnection();
		
			// construct the SQL statement
			final String SQL = SQL_SELECT + " WHERE " + sql;
		
		
			if (logger.isDebugEnabled()) {
				logger.debug( "Executing " + SQL);
			}
		
			// prepare statement
			stmt = conn.prepareStatement( SQL );
			stmt.setMaxRows( maxRows );
		
			// bind parameters
			for (int i=0; sqlParams!=null && i<sqlParams.length; i++ ) {
				stmt.setObject( i+1, sqlParams[i] );
			}
		
		
			rs = stmt.executeQuery();
		
			// fetch the results
			return fetchMultiResults(rs);
		}
		catch (Exception _e) {
			logger.error( "Exception: " + _e.getMessage(), _e );
			throw new XfcontractDaoException( "Exception: " + _e.getMessage(), _e );
		}
		finally {
			ResourceManager.close(rs);
			ResourceManager.close(stmt);
			if (!isConnSupplied) {
				ResourceManager.close(conn);
			}
		
		}
		
	}

}
