/*
 * This source file was generated by FireStorm/DAO.
 * 
 * If you purchase a full license for FireStorm/DAO you can customize this header file.
 * 
 * For more information please visit http://www.codefutures.com/products/firestorm
 */

package zt.cms.xf.common.jdbc;

import zt.cms.xf.common.dao.*;
import zt.cms.xf.common.factory.*;
import java.math.BigDecimal;
import java.util.Date;
import zt.cms.xf.common.dto.*;
import zt.cms.xf.common.exceptions.*;
import java.sql.Connection;
import java.util.Collection;
import org.apache.log4j.Logger;
import java.sql.PreparedStatement;
import java.sql.Statement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Time;
import java.util.List;
import java.util.Iterator;
import java.util.ArrayList;

public class XfifbankdetlDaoImpl extends AbstractDAO implements XfifbankdetlDao
{
	/** 
	 * The factory class for this DAO has two versions of the create() method - one that
takes no arguments and one that takes a Connection argument. If the Connection version
is chosen then the connection will be stored in this attribute and will be used by all
calls to this DAO, otherwise a new Connection will be allocated for each operation.
	 */
	protected java.sql.Connection userConn;

	protected static final Logger logger = Logger.getLogger( XfifbankdetlDaoImpl.class );

	/** 
	 * All finder methods in this class use this SELECT constant to build their queries
	 */
	protected final String SQL_SELECT = "SELECT JOURNALNO, TXNDATE, TXNTYPE, TOTALCOUNT, CURRCOUNT, MULTIFLAG, TRANSFERACT, TOTALAMT, FAILAMT, FAILCOUNT, USAGE, REMARK, REMARK1, REMARK2, STARTDATE, STATUS, BANKID, SYSTEMTYPE, OPERATORID, OPERATEDATE, CHECKERID, CHECKDATE, CREATORID, CREATEDATE, CREATEFORM, UPDATORID, UPDATEDATE, UPDATEFORM, BIZSEQNO, DATA, LOG FROM " + getTableName() + "";

	/** 
	 * Finder methods will pass this value to the JDBC setMaxRows method
	 */
	protected int maxRows;

	/** 
	 * SQL INSERT statement for this table
	 */
	protected final String SQL_INSERT = "INSERT INTO " + getTableName() + " ( JOURNALNO, TXNDATE, TXNTYPE, TOTALCOUNT, CURRCOUNT, MULTIFLAG, TRANSFERACT, TOTALAMT, FAILAMT, FAILCOUNT, USAGE, REMARK, REMARK1, REMARK2, STARTDATE, STATUS, BANKID, SYSTEMTYPE, OPERATORID, OPERATEDATE, CHECKERID, CHECKDATE, CREATORID, CREATEDATE, CREATEFORM, UPDATORID, UPDATEDATE, UPDATEFORM, BIZSEQNO, DATA, LOG ) VALUES ( ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, EMPTY_CLOB(), ? )";

	/** 
	 * SQL UPDATE statement for this table
	 */
	protected final String SQL_UPDATE = "UPDATE " + getTableName() + " SET JOURNALNO = ?, TXNDATE = ?, TXNTYPE = ?, TOTALCOUNT = ?, CURRCOUNT = ?, MULTIFLAG = ?, TRANSFERACT = ?, TOTALAMT = ?, FAILAMT = ?, FAILCOUNT = ?, USAGE = ?, REMARK = ?, REMARK1 = ?, REMARK2 = ?, STARTDATE = ?, STATUS = ?, BANKID = ?, SYSTEMTYPE = ?, OPERATORID = ?, OPERATEDATE = ?, CHECKERID = ?, CHECKDATE = ?, CREATORID = ?, CREATEDATE = ?, CREATEFORM = ?, UPDATORID = ?, UPDATEDATE = ?, UPDATEFORM = ?, BIZSEQNO = ?, DATA = EMPTY_CLOB(), LOG = ? WHERE JOURNALNO = ?";

	/** 
	 * SQL DELETE statement for this table
	 */
	protected final String SQL_DELETE = "DELETE FROM " + getTableName() + " WHERE JOURNALNO = ?";

	/** 
	 * Index of column JOURNALNO
	 */
	protected static final int COLUMN_JOURNALNO = 1;

	/** 
	 * Index of column TXNDATE
	 */
	protected static final int COLUMN_TXNDATE = 2;

	/** 
	 * Index of column TXNTYPE
	 */
	protected static final int COLUMN_TXNTYPE = 3;

	/** 
	 * Index of column TOTALCOUNT
	 */
	protected static final int COLUMN_TOTALCOUNT = 4;

	/** 
	 * Index of column CURRCOUNT
	 */
	protected static final int COLUMN_CURRCOUNT = 5;

	/** 
	 * Index of column MULTIFLAG
	 */
	protected static final int COLUMN_MULTIFLAG = 6;

	/** 
	 * Index of column TRANSFERACT
	 */
	protected static final int COLUMN_TRANSFERACT = 7;

	/** 
	 * Index of column TOTALAMT
	 */
	protected static final int COLUMN_TOTALAMT = 8;

	/** 
	 * Index of column FAILAMT
	 */
	protected static final int COLUMN_FAILAMT = 9;

	/** 
	 * Index of column FAILCOUNT
	 */
	protected static final int COLUMN_FAILCOUNT = 10;

	/** 
	 * Index of column USAGE
	 */
	protected static final int COLUMN_USAGE = 11;

	/** 
	 * Index of column REMARK
	 */
	protected static final int COLUMN_REMARK = 12;

	/** 
	 * Index of column REMARK1
	 */
	protected static final int COLUMN_REMARK1 = 13;

	/** 
	 * Index of column REMARK2
	 */
	protected static final int COLUMN_REMARK2 = 14;

	/** 
	 * Index of column STARTDATE
	 */
	protected static final int COLUMN_STARTDATE = 15;

	/** 
	 * Index of column STATUS
	 */
	protected static final int COLUMN_STATUS = 16;

	/** 
	 * Index of column BANKID
	 */
	protected static final int COLUMN_BANKID = 17;

	/** 
	 * Index of column SYSTEMTYPE
	 */
	protected static final int COLUMN_SYSTEMTYPE = 18;

	/** 
	 * Index of column OPERATORID
	 */
	protected static final int COLUMN_OPERATORID = 19;

	/** 
	 * Index of column OPERATEDATE
	 */
	protected static final int COLUMN_OPERATEDATE = 20;

	/** 
	 * Index of column CHECKERID
	 */
	protected static final int COLUMN_CHECKERID = 21;

	/** 
	 * Index of column CHECKDATE
	 */
	protected static final int COLUMN_CHECKDATE = 22;

	/** 
	 * Index of column CREATORID
	 */
	protected static final int COLUMN_CREATORID = 23;

	/** 
	 * Index of column CREATEDATE
	 */
	protected static final int COLUMN_CREATEDATE = 24;

	/** 
	 * Index of column CREATEFORM
	 */
	protected static final int COLUMN_CREATEFORM = 25;

	/** 
	 * Index of column UPDATORID
	 */
	protected static final int COLUMN_UPDATORID = 26;

	/** 
	 * Index of column UPDATEDATE
	 */
	protected static final int COLUMN_UPDATEDATE = 27;

	/** 
	 * Index of column UPDATEFORM
	 */
	protected static final int COLUMN_UPDATEFORM = 28;

	/** 
	 * Index of column BIZSEQNO
	 */
	protected static final int COLUMN_BIZSEQNO = 29;

	/** 
	 * Index of column DATA
	 */
	protected static final int COLUMN_DATA = 30;

	/** 
	 * Index of column LOG
	 */
	protected static final int COLUMN_LOG = 31;

	/** 
	 * Number of columns
	 */
	protected static final int NUMBER_OF_COLUMNS = 31;

	/** 
	 * Index of primary-key column JOURNALNO
	 */
	protected static final int PK_COLUMN_JOURNALNO = 1;

	/** 
	 * Inserts a new row in the XFIFBANKDETL table.
	 */
	public XfifbankdetlPk insert(Xfifbankdetl dto) throws XfifbankdetlDaoException
	{
		long t1 = System.currentTimeMillis();
		// declare variables
		final boolean isConnSupplied = (userConn != null);
		Connection conn = null;
		PreparedStatement stmt = null;
		ResultSet rs = null;
		
		try {
			// get the user-specified connection or get a connection from the ResourceManager
			conn = isConnSupplied ? userConn : ResourceManager.getConnection();
		
			stmt = conn.prepareStatement( SQL_INSERT );
			int index = 1;
			stmt.setString( index++, dto.getJournalno() );
			stmt.setString( index++, dto.getTxndate() );
			stmt.setString( index++, dto.getTxntype() );
			stmt.setBigDecimal( index++, dto.getTotalcount() );
			stmt.setBigDecimal( index++, dto.getCurrcount() );
			stmt.setString( index++, dto.getMultiflag() );
			stmt.setString( index++, dto.getTransferact() );
			stmt.setBigDecimal( index++, dto.getTotalamt() );
			stmt.setBigDecimal( index++, dto.getFailamt() );
			stmt.setBigDecimal( index++, dto.getFailcount() );
			stmt.setString( index++, dto.getUsage() );
			stmt.setString( index++, dto.getRemark() );
			stmt.setString( index++, dto.getRemark1() );
			stmt.setString( index++, dto.getRemark2() );
			stmt.setTimestamp(index++, dto.getStartdate()==null ? null : new java.sql.Timestamp( dto.getStartdate().getTime() ) );
			stmt.setString( index++, dto.getStatus() );
			stmt.setString( index++, dto.getBankid() );
			stmt.setString( index++, dto.getSystemtype() );
			stmt.setString( index++, dto.getOperatorid() );
			stmt.setTimestamp(index++, dto.getOperatedate()==null ? null : new java.sql.Timestamp( dto.getOperatedate().getTime() ) );
			stmt.setString( index++, dto.getCheckerid() );
			stmt.setTimestamp(index++, dto.getCheckdate()==null ? null : new java.sql.Timestamp( dto.getCheckdate().getTime() ) );
			stmt.setString( index++, dto.getCreatorid() );
			stmt.setTimestamp(index++, dto.getCreatedate()==null ? null : new java.sql.Timestamp( dto.getCreatedate().getTime() ) );
			stmt.setString( index++, dto.getCreateform() );
			stmt.setString( index++, dto.getUpdatorid() );
			stmt.setTimestamp(index++, dto.getUpdatedate()==null ? null : new java.sql.Timestamp( dto.getUpdatedate().getTime() ) );
			stmt.setString( index++, dto.getUpdateform() );
			stmt.setString( index++, dto.getBizseqno() );
			// no need to bind value for LOB column
			stmt.setString( index++, dto.getLog() );
			if (logger.isDebugEnabled()) {
				logger.debug( "Executing " + SQL_INSERT + " with DTO: " + dto);
			}
		
			int rows = stmt.executeUpdate();
		
			// Update CLOB columns
			boolean oldAutoCommitValue = conn.getAutoCommit();
			conn.setAutoCommit(false);
			String lobSQL = "SELECT DATA FROM " + getTableName() + " WHERE JOURNALNO=? FOR UPDATE";
			index = 1;
			if (logger.isDebugEnabled()) {
				logger.debug( lobSQL);
			}
		
			PreparedStatement lobStmt = conn.prepareStatement( lobSQL );
			lobStmt.setString( index++, dto.getJournalno() );
			ResultSet lobRs = lobStmt.executeQuery();
			int lobIndex = 1;
			if (lobRs.next()) {
				super.updateClob( lobRs.getClob(lobIndex++), dto.getData());
			}
		
			conn.commit();
			conn.setAutoCommit(oldAutoCommitValue);
			if (logger.isDebugEnabled()) {
				logger.debug( "Updated LOB");
			}
		
			long t2 = System.currentTimeMillis();
			if (logger.isDebugEnabled()) {
				logger.debug( rows + " rows affected (" + (t2-t1) + " ms)");
			}
		
			reset(dto);
			return dto.createPk();
		}
		catch (Exception _e) {
			logger.error( "Exception: " + _e.getMessage(), _e );
			throw new XfifbankdetlDaoException( "Exception: " + _e.getMessage(), _e );
		}
		finally {
			ResourceManager.close(stmt);
			if (!isConnSupplied) {
				ResourceManager.close(conn);
			}
		
		}
		
	}

	/** 
	 * Updates a single row in the XFIFBANKDETL table.
	 */
	public void update(XfifbankdetlPk pk, Xfifbankdetl dto) throws XfifbankdetlDaoException
	{
		long t1 = System.currentTimeMillis();
		// declare variables
		final boolean isConnSupplied = (userConn != null);
		Connection conn = null;
		PreparedStatement stmt = null;
		
		try {
			// get the user-specified connection or get a connection from the ResourceManager
			conn = isConnSupplied ? userConn : ResourceManager.getConnection();
		
			if (logger.isDebugEnabled()) {
				logger.debug( "Executing " + SQL_UPDATE + " with DTO: " + dto);
			}
		
			stmt = conn.prepareStatement( SQL_UPDATE );
			int index=1;
			stmt.setString( index++, dto.getJournalno() );
			stmt.setString( index++, dto.getTxndate() );
			stmt.setString( index++, dto.getTxntype() );
			stmt.setBigDecimal( index++, dto.getTotalcount() );
			stmt.setBigDecimal( index++, dto.getCurrcount() );
			stmt.setString( index++, dto.getMultiflag() );
			stmt.setString( index++, dto.getTransferact() );
			stmt.setBigDecimal( index++, dto.getTotalamt() );
			stmt.setBigDecimal( index++, dto.getFailamt() );
			stmt.setBigDecimal( index++, dto.getFailcount() );
			stmt.setString( index++, dto.getUsage() );
			stmt.setString( index++, dto.getRemark() );
			stmt.setString( index++, dto.getRemark1() );
			stmt.setString( index++, dto.getRemark2() );
			stmt.setTimestamp(index++, dto.getStartdate()==null ? null : new java.sql.Timestamp( dto.getStartdate().getTime() ) );
			stmt.setString( index++, dto.getStatus() );
			stmt.setString( index++, dto.getBankid() );
			stmt.setString( index++, dto.getSystemtype() );
			stmt.setString( index++, dto.getOperatorid() );
			stmt.setTimestamp(index++, dto.getOperatedate()==null ? null : new java.sql.Timestamp( dto.getOperatedate().getTime() ) );
			stmt.setString( index++, dto.getCheckerid() );
			stmt.setTimestamp(index++, dto.getCheckdate()==null ? null : new java.sql.Timestamp( dto.getCheckdate().getTime() ) );
			stmt.setString( index++, dto.getCreatorid() );
			stmt.setTimestamp(index++, dto.getCreatedate()==null ? null : new java.sql.Timestamp( dto.getCreatedate().getTime() ) );
			stmt.setString( index++, dto.getCreateform() );
			stmt.setString( index++, dto.getUpdatorid() );
			stmt.setTimestamp(index++, dto.getUpdatedate()==null ? null : new java.sql.Timestamp( dto.getUpdatedate().getTime() ) );
			stmt.setString( index++, dto.getUpdateform() );
			stmt.setString( index++, dto.getBizseqno() );
			// no need to bind value for LOB column
			stmt.setString( index++, dto.getLog() );
			stmt.setString( 31, pk.getJournalno() );
			int rows = stmt.executeUpdate();
		
			// Update CLOB columns
			boolean oldAutoCommitValue = conn.getAutoCommit();
			conn.setAutoCommit(false);
			String lobSQL = "SELECT DATA FROM " + getTableName() + " WHERE JOURNALNO=? FOR UPDATE";
			index = 1;
			if (logger.isDebugEnabled()) {
				logger.debug( lobSQL);
			}
		
			PreparedStatement lobStmt = conn.prepareStatement( lobSQL );
			lobStmt.setString( index++, dto.getJournalno() );
			ResultSet lobRs = lobStmt.executeQuery();
			int lobIndex = 1;
			if (lobRs.next()) {
				super.updateClob( lobRs.getClob(lobIndex++), dto.getData());
			}
		
			conn.commit();
			conn.setAutoCommit(oldAutoCommitValue);
			if (logger.isDebugEnabled()) {
				logger.debug( "Updated LOB");
			}
		
			reset(dto);
			long t2 = System.currentTimeMillis();
			if (logger.isDebugEnabled()) {
				logger.debug( rows + " rows affected (" + (t2-t1) + " ms)");
			}
		
		}
		catch (Exception _e) {
			logger.error( "Exception: " + _e.getMessage(), _e );
			throw new XfifbankdetlDaoException( "Exception: " + _e.getMessage(), _e );
		}
		finally {
			ResourceManager.close(stmt);
			if (!isConnSupplied) {
				ResourceManager.close(conn);
			}
		
		}
		
	}

	/** 
	 * Deletes a single row in the XFIFBANKDETL table.
	 */
	public void delete(XfifbankdetlPk pk) throws XfifbankdetlDaoException
	{
		long t1 = System.currentTimeMillis();
		// declare variables
		final boolean isConnSupplied = (userConn != null);
		Connection conn = null;
		PreparedStatement stmt = null;
		
		try {
			// get the user-specified connection or get a connection from the ResourceManager
			conn = isConnSupplied ? userConn : ResourceManager.getConnection();
		
			if (logger.isDebugEnabled()) {
				logger.debug( "Executing " + SQL_DELETE + " with PK: " + pk);
			}
		
			stmt = conn.prepareStatement( SQL_DELETE );
			stmt.setString( 1, pk.getJournalno() );
			int rows = stmt.executeUpdate();
			long t2 = System.currentTimeMillis();
			if (logger.isDebugEnabled()) {
				logger.debug( rows + " rows affected (" + (t2-t1) + " ms)");
			}
		
		}
		catch (Exception _e) {
			logger.error( "Exception: " + _e.getMessage(), _e );
			throw new XfifbankdetlDaoException( "Exception: " + _e.getMessage(), _e );
		}
		finally {
			ResourceManager.close(stmt);
			if (!isConnSupplied) {
				ResourceManager.close(conn);
			}
		
		}
		
	}

	/** 
	 * Returns the rows from the XFIFBANKDETL table that matches the specified primary-key value.
	 */
	public Xfifbankdetl findByPrimaryKey(XfifbankdetlPk pk) throws XfifbankdetlDaoException
	{
		return findByPrimaryKey( pk.getJournalno() );
	}

	/** 
	 * Returns all rows from the XFIFBANKDETL table that match the criteria 'JOURNALNO = :journalno'.
	 */
	public Xfifbankdetl findByPrimaryKey(String journalno) throws XfifbankdetlDaoException
	{
		Xfifbankdetl ret[] = findByDynamicSelect( SQL_SELECT + " WHERE JOURNALNO = ?", new Object[] { journalno } );
		return ret.length==0 ? null : ret[0];
	}

	/** 
	 * Returns all rows from the XFIFBANKDETL table that match the criteria ''.
	 */
	public Xfifbankdetl[] findAll() throws XfifbankdetlDaoException
	{
		return findByDynamicSelect( SQL_SELECT + " ORDER BY JOURNALNO", null );
	}

	/** 
	 * Returns all rows from the XFIFBANKDETL table that match the criteria 'JOURNALNO = :journalno'.
	 */
	public Xfifbankdetl[] findWhereJournalnoEquals(String journalno) throws XfifbankdetlDaoException
	{
		return findByDynamicSelect( SQL_SELECT + " WHERE JOURNALNO = ? ORDER BY JOURNALNO", new Object[] { journalno } );
	}

	/** 
	 * Returns all rows from the XFIFBANKDETL table that match the criteria 'BIZSEQNO = :bizseqno'.
	 */
	public Xfifbankdetl[] findWhereBizseqnoEquals(String bizseqno) throws XfifbankdetlDaoException
	{
		return findByDynamicSelect( SQL_SELECT + " WHERE BIZSEQNO = ? ORDER BY BIZSEQNO", new Object[] { bizseqno } );
	}

	/** 
	 * Returns all rows from the XFIFBANKDETL table that match the criteria 'TXNDATE = :txndate'.
	 */
	public Xfifbankdetl[] findWhereTxndateEquals(String txndate) throws XfifbankdetlDaoException
	{
		return findByDynamicSelect( SQL_SELECT + " WHERE TXNDATE = ? ORDER BY TXNDATE", new Object[] { txndate } );
	}

	/** 
	 * Returns all rows from the XFIFBANKDETL table that match the criteria 'TXNTYPE = :txntype'.
	 */
	public Xfifbankdetl[] findWhereTxntypeEquals(String txntype) throws XfifbankdetlDaoException
	{
		return findByDynamicSelect( SQL_SELECT + " WHERE TXNTYPE = ? ORDER BY TXNTYPE", new Object[] { txntype } );
	}

	/** 
	 * Returns all rows from the XFIFBANKDETL table that match the criteria 'TOTALCOUNT = :totalcount'.
	 */
	public Xfifbankdetl[] findWhereTotalcountEquals(BigDecimal totalcount) throws XfifbankdetlDaoException
	{
		return findByDynamicSelect( SQL_SELECT + " WHERE TOTALCOUNT = ? ORDER BY TOTALCOUNT", new Object[] { totalcount } );
	}

	/** 
	 * Returns all rows from the XFIFBANKDETL table that match the criteria 'CURRCOUNT = :currcount'.
	 */
	public Xfifbankdetl[] findWhereCurrcountEquals(BigDecimal currcount) throws XfifbankdetlDaoException
	{
		return findByDynamicSelect( SQL_SELECT + " WHERE CURRCOUNT = ? ORDER BY CURRCOUNT", new Object[] { currcount } );
	}

	/** 
	 * Returns all rows from the XFIFBANKDETL table that match the criteria 'MULTIFLAG = :multiflag'.
	 */
	public Xfifbankdetl[] findWhereMultiflagEquals(String multiflag) throws XfifbankdetlDaoException
	{
		return findByDynamicSelect( SQL_SELECT + " WHERE MULTIFLAG = ? ORDER BY MULTIFLAG", new Object[] { multiflag } );
	}

	/** 
	 * Returns all rows from the XFIFBANKDETL table that match the criteria 'TRANSFERACT = :transferact'.
	 */
	public Xfifbankdetl[] findWhereTransferactEquals(String transferact) throws XfifbankdetlDaoException
	{
		return findByDynamicSelect( SQL_SELECT + " WHERE TRANSFERACT = ? ORDER BY TRANSFERACT", new Object[] { transferact } );
	}

	/** 
	 * Returns all rows from the XFIFBANKDETL table that match the criteria 'TOTALAMT = :totalamt'.
	 */
	public Xfifbankdetl[] findWhereTotalamtEquals(BigDecimal totalamt) throws XfifbankdetlDaoException
	{
		return findByDynamicSelect( SQL_SELECT + " WHERE TOTALAMT = ? ORDER BY TOTALAMT", new Object[] { totalamt } );
	}

	/** 
	 * Returns all rows from the XFIFBANKDETL table that match the criteria 'FAILAMT = :failamt'.
	 */
	public Xfifbankdetl[] findWhereFailamtEquals(BigDecimal failamt) throws XfifbankdetlDaoException
	{
		return findByDynamicSelect( SQL_SELECT + " WHERE FAILAMT = ? ORDER BY FAILAMT", new Object[] { failamt } );
	}

	/** 
	 * Returns all rows from the XFIFBANKDETL table that match the criteria 'FAILCOUNT = :failcount'.
	 */
	public Xfifbankdetl[] findWhereFailcountEquals(BigDecimal failcount) throws XfifbankdetlDaoException
	{
		return findByDynamicSelect( SQL_SELECT + " WHERE FAILCOUNT = ? ORDER BY FAILCOUNT", new Object[] { failcount } );
	}

	/** 
	 * Returns all rows from the XFIFBANKDETL table that match the criteria 'USAGE = :usage'.
	 */
	public Xfifbankdetl[] findWhereUsageEquals(String usage) throws XfifbankdetlDaoException
	{
		return findByDynamicSelect( SQL_SELECT + " WHERE USAGE = ? ORDER BY USAGE", new Object[] { usage } );
	}

	/** 
	 * Returns all rows from the XFIFBANKDETL table that match the criteria 'REMARK = :remark'.
	 */
	public Xfifbankdetl[] findWhereRemarkEquals(String remark) throws XfifbankdetlDaoException
	{
		return findByDynamicSelect( SQL_SELECT + " WHERE REMARK = ? ORDER BY REMARK", new Object[] { remark } );
	}

	/** 
	 * Returns all rows from the XFIFBANKDETL table that match the criteria 'REMARK1 = :remark1'.
	 */
	public Xfifbankdetl[] findWhereRemark1Equals(String remark1) throws XfifbankdetlDaoException
	{
		return findByDynamicSelect( SQL_SELECT + " WHERE REMARK1 = ? ORDER BY REMARK1", new Object[] { remark1 } );
	}

	/** 
	 * Returns all rows from the XFIFBANKDETL table that match the criteria 'REMARK2 = :remark2'.
	 */
	public Xfifbankdetl[] findWhereRemark2Equals(String remark2) throws XfifbankdetlDaoException
	{
		return findByDynamicSelect( SQL_SELECT + " WHERE REMARK2 = ? ORDER BY REMARK2", new Object[] { remark2 } );
	}

	/** 
	 * Returns all rows from the XFIFBANKDETL table that match the criteria 'STARTDATE = :startdate'.
	 */
	public Xfifbankdetl[] findWhereStartdateEquals(Date startdate) throws XfifbankdetlDaoException
	{
		return findByDynamicSelect( SQL_SELECT + " WHERE STARTDATE = ? ORDER BY STARTDATE", new Object[] { startdate==null ? null : new java.sql.Timestamp( startdate.getTime() ) } );
	}

	/** 
	 * Returns all rows from the XFIFBANKDETL table that match the criteria 'STATUS = :status'.
	 */
	public Xfifbankdetl[] findWhereStatusEquals(String status) throws XfifbankdetlDaoException
	{
		return findByDynamicSelect( SQL_SELECT + " WHERE STATUS = ? ORDER BY STATUS", new Object[] { status } );
	}

	/** 
	 * Returns all rows from the XFIFBANKDETL table that match the criteria 'BANKID = :bankid'.
	 */
	public Xfifbankdetl[] findWhereBankidEquals(String bankid) throws XfifbankdetlDaoException
	{
		return findByDynamicSelect( SQL_SELECT + " WHERE BANKID = ? ORDER BY BANKID", new Object[] { bankid } );
	}

	/** 
	 * Returns all rows from the XFIFBANKDETL table that match the criteria 'SYSTEMTYPE = :systemtype'.
	 */
	public Xfifbankdetl[] findWhereSystemtypeEquals(String systemtype) throws XfifbankdetlDaoException
	{
		return findByDynamicSelect( SQL_SELECT + " WHERE SYSTEMTYPE = ? ORDER BY SYSTEMTYPE", new Object[] { systemtype } );
	}

	/** 
	 * Returns all rows from the XFIFBANKDETL table that match the criteria 'OPERATORID = :operatorid'.
	 */
	public Xfifbankdetl[] findWhereOperatoridEquals(String operatorid) throws XfifbankdetlDaoException
	{
		return findByDynamicSelect( SQL_SELECT + " WHERE OPERATORID = ? ORDER BY OPERATORID", new Object[] { operatorid } );
	}

	/** 
	 * Returns all rows from the XFIFBANKDETL table that match the criteria 'OPERATEDATE = :operatedate'.
	 */
	public Xfifbankdetl[] findWhereOperatedateEquals(Date operatedate) throws XfifbankdetlDaoException
	{
		return findByDynamicSelect( SQL_SELECT + " WHERE OPERATEDATE = ? ORDER BY OPERATEDATE", new Object[] { operatedate==null ? null : new java.sql.Timestamp( operatedate.getTime() ) } );
	}

	/** 
	 * Returns all rows from the XFIFBANKDETL table that match the criteria 'CHECKERID = :checkerid'.
	 */
	public Xfifbankdetl[] findWhereCheckeridEquals(String checkerid) throws XfifbankdetlDaoException
	{
		return findByDynamicSelect( SQL_SELECT + " WHERE CHECKERID = ? ORDER BY CHECKERID", new Object[] { checkerid } );
	}

	/** 
	 * Returns all rows from the XFIFBANKDETL table that match the criteria 'CHECKDATE = :checkdate'.
	 */
	public Xfifbankdetl[] findWhereCheckdateEquals(Date checkdate) throws XfifbankdetlDaoException
	{
		return findByDynamicSelect( SQL_SELECT + " WHERE CHECKDATE = ? ORDER BY CHECKDATE", new Object[] { checkdate==null ? null : new java.sql.Timestamp( checkdate.getTime() ) } );
	}

	/** 
	 * Returns all rows from the XFIFBANKDETL table that match the criteria 'CREATORID = :creatorid'.
	 */
	public Xfifbankdetl[] findWhereCreatoridEquals(String creatorid) throws XfifbankdetlDaoException
	{
		return findByDynamicSelect( SQL_SELECT + " WHERE CREATORID = ? ORDER BY CREATORID", new Object[] { creatorid } );
	}

	/** 
	 * Returns all rows from the XFIFBANKDETL table that match the criteria 'CREATEDATE = :createdate'.
	 */
	public Xfifbankdetl[] findWhereCreatedateEquals(Date createdate) throws XfifbankdetlDaoException
	{
		return findByDynamicSelect( SQL_SELECT + " WHERE CREATEDATE = ? ORDER BY CREATEDATE", new Object[] { createdate==null ? null : new java.sql.Timestamp( createdate.getTime() ) } );
	}

	/** 
	 * Returns all rows from the XFIFBANKDETL table that match the criteria 'CREATEFORM = :createform'.
	 */
	public Xfifbankdetl[] findWhereCreateformEquals(String createform) throws XfifbankdetlDaoException
	{
		return findByDynamicSelect( SQL_SELECT + " WHERE CREATEFORM = ? ORDER BY CREATEFORM", new Object[] { createform } );
	}

	/** 
	 * Returns all rows from the XFIFBANKDETL table that match the criteria 'UPDATORID = :updatorid'.
	 */
	public Xfifbankdetl[] findWhereUpdatoridEquals(String updatorid) throws XfifbankdetlDaoException
	{
		return findByDynamicSelect( SQL_SELECT + " WHERE UPDATORID = ? ORDER BY UPDATORID", new Object[] { updatorid } );
	}

	/** 
	 * Returns all rows from the XFIFBANKDETL table that match the criteria 'UPDATEDATE = :updatedate'.
	 */
	public Xfifbankdetl[] findWhereUpdatedateEquals(Date updatedate) throws XfifbankdetlDaoException
	{
		return findByDynamicSelect( SQL_SELECT + " WHERE UPDATEDATE = ? ORDER BY UPDATEDATE", new Object[] { updatedate==null ? null : new java.sql.Timestamp( updatedate.getTime() ) } );
	}

	/** 
	 * Returns all rows from the XFIFBANKDETL table that match the criteria 'UPDATEFORM = :updateform'.
	 */
	public Xfifbankdetl[] findWhereUpdateformEquals(String updateform) throws XfifbankdetlDaoException
	{
		return findByDynamicSelect( SQL_SELECT + " WHERE UPDATEFORM = ? ORDER BY UPDATEFORM", new Object[] { updateform } );
	}

	/** 
	 * Returns all rows from the XFIFBANKDETL table that match the criteria 'DATA = :data'.
	 */
	public Xfifbankdetl[] findWhereDataEquals(String data) throws XfifbankdetlDaoException
	{
		return findByDynamicSelect( SQL_SELECT + " WHERE DATA = ? ORDER BY DATA", new Object[] { data } );
	}

	/** 
	 * Returns all rows from the XFIFBANKDETL table that match the criteria 'LOG = :log'.
	 */
	public Xfifbankdetl[] findWhereLogEquals(String log) throws XfifbankdetlDaoException
	{
		return findByDynamicSelect( SQL_SELECT + " WHERE LOG = ? ORDER BY LOG", new Object[] { log } );
	}

	/**
	 * Method 'XfifbankdetlDaoImpl'
	 * 
	 */
	public XfifbankdetlDaoImpl()
	{
	}

	/**
	 * Method 'XfifbankdetlDaoImpl'
	 * 
	 * @param userConn
	 */
	public XfifbankdetlDaoImpl(final java.sql.Connection userConn)
	{
		this.userConn = userConn;
	}

	/** 
	 * Sets the value of maxRows
	 */
	public void setMaxRows(int maxRows)
	{
		this.maxRows = maxRows;
	}

	/** 
	 * Gets the value of maxRows
	 */
	public int getMaxRows()
	{
		return maxRows;
	}

	/**
	 * Method 'getTableName'
	 * 
	 * @return String
	 */
	public String getTableName()
	{
		return "CMS.XFIFBANKDETL";
	}

	/** 
	 * Fetches a single row from the result set
	 */
	protected Xfifbankdetl fetchSingleResult(ResultSet rs) throws SQLException
	{
		if (rs.next()) {
			Xfifbankdetl dto = new Xfifbankdetl();
			populateDto( dto, rs);
			return dto;
		} else {
			return null;
		}
		
	}

	/** 
	 * Fetches multiple rows from the result set
	 */
	protected Xfifbankdetl[] fetchMultiResults(ResultSet rs) throws SQLException
	{
		Collection resultList = new ArrayList();
		while (rs.next()) {
			Xfifbankdetl dto = new Xfifbankdetl();
			populateDto( dto, rs);
			resultList.add( dto );
		}
		
		Xfifbankdetl ret[] = new Xfifbankdetl[ resultList.size() ];
		resultList.toArray( ret );
		return ret;
	}

	/** 
	 * Populates a DTO with data from a ResultSet
	 */
	protected void populateDto(Xfifbankdetl dto, ResultSet rs) throws SQLException
	{
		dto.setJournalno( rs.getString( COLUMN_JOURNALNO ) );
		dto.setTxndate( rs.getString( COLUMN_TXNDATE ) );
		dto.setTxntype( rs.getString( COLUMN_TXNTYPE ) );
		dto.setTotalcount( rs.getBigDecimal(COLUMN_TOTALCOUNT));
		dto.setCurrcount( rs.getBigDecimal(COLUMN_CURRCOUNT));
		dto.setMultiflag( rs.getString( COLUMN_MULTIFLAG ) );
		dto.setTransferact( rs.getString( COLUMN_TRANSFERACT ) );
		dto.setTotalamt( rs.getBigDecimal(COLUMN_TOTALAMT));
		dto.setFailamt( rs.getBigDecimal(COLUMN_FAILAMT));
		dto.setFailcount( rs.getBigDecimal(COLUMN_FAILCOUNT));
		dto.setUsage( rs.getString( COLUMN_USAGE ) );
		dto.setRemark( rs.getString( COLUMN_REMARK ) );
		dto.setRemark1( rs.getString( COLUMN_REMARK1 ) );
		dto.setRemark2( rs.getString( COLUMN_REMARK2 ) );
		dto.setStartdate( rs.getTimestamp(COLUMN_STARTDATE ) );
		dto.setStatus( rs.getString( COLUMN_STATUS ) );
		dto.setBankid( rs.getString( COLUMN_BANKID ) );
		dto.setSystemtype( rs.getString( COLUMN_SYSTEMTYPE ) );
		dto.setOperatorid( rs.getString( COLUMN_OPERATORID ) );
		dto.setOperatedate( rs.getTimestamp(COLUMN_OPERATEDATE ) );
		dto.setCheckerid( rs.getString( COLUMN_CHECKERID ) );
		dto.setCheckdate( rs.getTimestamp(COLUMN_CHECKDATE ) );
		dto.setCreatorid( rs.getString( COLUMN_CREATORID ) );
		dto.setCreatedate( rs.getTimestamp(COLUMN_CREATEDATE ) );
		dto.setCreateform( rs.getString( COLUMN_CREATEFORM ) );
		dto.setUpdatorid( rs.getString( COLUMN_UPDATORID ) );
		dto.setUpdatedate( rs.getTimestamp(COLUMN_UPDATEDATE ) );
		dto.setUpdateform( rs.getString( COLUMN_UPDATEFORM ) );
		dto.setBizseqno( rs.getString( COLUMN_BIZSEQNO ) );
		dto.setData( super.getClobColumn(rs, COLUMN_DATA ) );
		dto.setLog( rs.getString( COLUMN_LOG ) );
	}

	/** 
	 * Resets the modified attributes in the DTO
	 */
	protected void reset(Xfifbankdetl dto)
	{
	}

	/** 
	 * Returns all rows from the XFIFBANKDETL table that match the specified arbitrary SQL statement
	 */
	public Xfifbankdetl[] findByDynamicSelect(String sql, Object[] sqlParams) throws XfifbankdetlDaoException
	{
		// declare variables
		final boolean isConnSupplied = (userConn != null);
		Connection conn = null;
		PreparedStatement stmt = null;
		ResultSet rs = null;
		
		try {
			// get the user-specified connection or get a connection from the ResourceManager
			conn = isConnSupplied ? userConn : ResourceManager.getConnection();
		
			// construct the SQL statement
			final String SQL = sql;
		
		
			if (logger.isDebugEnabled()) {
				logger.debug( "Executing " + SQL);
			}
		
			// prepare statement
			stmt = conn.prepareStatement( SQL );
			stmt.setMaxRows( maxRows );
		
			// bind parameters
			for (int i=0; sqlParams!=null && i<sqlParams.length; i++ ) {
				stmt.setObject( i+1, sqlParams[i] );
			}
		
		
			rs = stmt.executeQuery();
		
			// fetch the results
			return fetchMultiResults(rs);
		}
		catch (Exception _e) {
			logger.error( "Exception: " + _e.getMessage(), _e );
			throw new XfifbankdetlDaoException( "Exception: " + _e.getMessage(), _e );
		}
		finally {
			ResourceManager.close(rs);
			ResourceManager.close(stmt);
			if (!isConnSupplied) {
				ResourceManager.close(conn);
			}
		
		}
		
	}

	/** 
	 * Returns all rows from the XFIFBANKDETL table that match the specified arbitrary SQL statement
	 */
	public Xfifbankdetl[] findByDynamicWhere(String sql, Object[] sqlParams) throws XfifbankdetlDaoException
	{
		// declare variables
		final boolean isConnSupplied = (userConn != null);
		Connection conn = null;
		PreparedStatement stmt = null;
		ResultSet rs = null;
		
		try {
			// get the user-specified connection or get a connection from the ResourceManager
			conn = isConnSupplied ? userConn : ResourceManager.getConnection();
		
			// construct the SQL statement
			final String SQL = SQL_SELECT + " WHERE " + sql;
		
		
			if (logger.isDebugEnabled()) {
				logger.debug( "Executing " + SQL);
			}
		
			// prepare statement
			stmt = conn.prepareStatement( SQL );
			stmt.setMaxRows( maxRows );
		
			// bind parameters
			for (int i=0; sqlParams!=null && i<sqlParams.length; i++ ) {
				stmt.setObject( i+1, sqlParams[i] );
			}
		
		
			rs = stmt.executeQuery();
		
			// fetch the results
			return fetchMultiResults(rs);
		}
		catch (Exception _e) {
			logger.error( "Exception: " + _e.getMessage(), _e );
			throw new XfifbankdetlDaoException( "Exception: " + _e.getMessage(), _e );
		}
		finally {
			ResourceManager.close(rs);
			ResourceManager.close(stmt);
			if (!isConnSupplied) {
				ResourceManager.close(conn);
			}
		
		}
		
	}

}
